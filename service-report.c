/*
    Copyright (C) 2013 Phil Wieland

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    phil@philwieland.com

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <regex.h>
#include <time.h>
#include <mysql.h>
#include <unistd.h>

#include "misc.h"
#include "db.h"

static void report(const char * const tiploc, const word year, const word month);
static void report_day(const char * const tiploc, time_t when);
static void report_train_day(const dword cif_schedule_id, const time_t when, const char * const tiploc);
static char * percentage(const dword num, const dword den);

#define NAME "service-report"
#define BUILD "V609"

static word debug;
static word bus;
static word nlate, nlater, ncape, nbus, ntrain;
static word glate, glater, gcape, gbus, gtrain;

// Days runs fields
static const char * days_runs[8] = {"runs_su", "runs_mo", "runs_tu", "runs_we", "runs_th", "runs_fr", "runs_sa", "runs_su"};

// (Hours * 60 + Minutes) * 4
#define DAY_START  4*60*4

static const char * days[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

int main(int argc, char **argv)
{
   int c;
   char config_file_path[256];
   word month, year;
   word usage = false;

   strcpy(config_file_path, "/etc/openrail.conf");
   debug = false;

   while ((c = getopt (argc, argv, ":c:d")) != -1)
   {
      switch (c)
      {
      case 'c':
         strcpy(config_file_path, optarg);
         break;
      case 'd':
         debug = true;
         break;
      case ':':
         break;
      case '?':
      default:
         usage = true;
         break;
      }
   }

   if(argc - optind < 3)
   {
      usage = true;
   }
   if(load_config(config_file_path))
   {
      printf("Failed to read config file \"%s\".\n", config_file_path);
      usage = true;
   }
   if(!usage)
   {
      if(strlen(argv[optind]) > 8) usage = true;
      month = atoi(argv[optind+1]);
      year  = atoi(argv[optind+2]);
      if(month < 1 || month > 12 || year < 2013 || year > 2099) usage = true;
   }

   if(usage)
   {
      printf("\tUsage: %s [-c /path/to/config/file.conf] [-d] <TIPLOC> <month> <year>\n\n", argv[0] );
      exit(1);
   }

   // Initialise logging
   _log_init("", debug?1:0);

   // Initialise database
   db_init(conf.db_server, conf.db_user, conf.db_pass, conf.db_name);

   report(argv[optind], year, month);

   exit(0);
}

static void report(const char * const tiploc, const word year, const word month)
{
   char l[512];
   time_t when;
   struct tm broken;
   sprintf(l, "Reporting on \"%s\".  Month is %02d/%d.", tiploc, month, year);
   _log(GENERAL, l);

   broken.tm_mday = 1;
   broken.tm_mon = month - 1;
   broken.tm_year = year - 1900;
      
   broken.tm_hour = 12;
   broken.tm_min = 0;
   broken.tm_sec = 0;
   broken.tm_isdst = -1;
   when = timegm(&broken);

   glate = glater = gcape = gbus = gtrain = 0;

   printf("<!-- Report for trains at %s during %02d/%d generated by %s build %s -->\n\n", tiploc, month, year, NAME, BUILD);
   
   while(broken.tm_mon == month - 1)
   {
      report_day(tiploc, when);

      when += 24*60*60;
      broken = *gmtime(&when);
   }

   if(gtrain)
   {
      printf("<tr><td>%s</td><td>%d</td><td>%d</td><td>(%s%%)</td>",
             "Month", gtrain, gtrain-gcape, percentage(gtrain-gcape, gtrain));
      printf("<td>%d</td><td>(%s%%)</td>",
             gtrain - glate, percentage(gtrain - glate, gtrain));
      printf("<td>%d</td><td>(%s%%)</td><td>%s</td></tr>\n",
             gtrain - glater, percentage(gtrain - glater, gtrain), "&nbsp;");
   }
   else
   {
      printf("<tr><td>%s</td><td>%d</td><td>%d</td><td>&nbsp;</td>",
             "Month", gtrain, gtrain-gcape);
      printf("<td>%d</td><td>&nbsp;</td>",
             gtrain - glate);
      printf("<td>%d</td><td>&nbsp;</td><td>%s</td></tr>\n",
             gtrain - glater, "&nbsp;");
   }
   printf("<!-- End of report -->\n\n"); 
  
}

static void report_day(const char * const tiploc, time_t when)
{
   MYSQL_RES * result0, * result1;
   MYSQL_ROW row0, row1;
   char query[4096], zs[256];
   // When will be 12:00:00Z on the day in question (Or 11:00 or 13:00 if the clocks have changed)

#define MAX_TRAINS 2048
   struct train_details
   {
      dword cif_schedule_id;
      byte next_day;
      byte valid;
      word sort_time;
      char cif_train_uid[8];
      char cif_stp_indicator;
   } 
   trains[MAX_TRAINS];
   word train_sequence[MAX_TRAINS];

   word train_count;

   //                    0                          1                      2                             3         4
   strcpy(query, "SELECT cif_schedules.id, cif_schedules.CIF_train_uid, cif_schedules.CIF_stp_indicator, next_day, sort_time");
   strcat(query, " FROM cif_schedules INNER JOIN cif_schedule_locations");
   strcat(query, " ON cif_schedules.id = cif_schedule_locations.cif_schedule_id");
   sprintf(zs, " WHERE (cif_schedule_locations.tiploc_code = '%s')", tiploc);
   strcat(query, zs);
   
   strcat(query, " AND (cif_schedules.CIF_stp_indicator = 'N' OR cif_schedules.CIF_stp_indicator = 'P' OR cif_schedules.CIF_stp_indicator = 'O')");
   
   sprintf(zs, " AND deleted >= %ld", when + (12*60*60));
   strcat(query, zs);
   
   // Select the day
   struct tm * broken = gmtime(&when);
   word day = broken->tm_wday;
   word mday = broken->tm_mday;
   word yest = (day + 6) % 7;
   word tom = (day + 1) % 7;
      
   sprintf(zs, " AND ((((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld) AND (NOT next_day)) AND (sort_time >= %d))",  days_runs[day],  when + 12*60*60, when - 12*60*60, DAY_START);
   strcat(query, zs);
   sprintf(zs, " OR   (((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld) AND (    next_day)) AND (sort_time >= %d))",  days_runs[yest], when - 12*60*60, when - 36*60*60, DAY_START);
   strcat(query, zs);
   sprintf(zs, " OR   (((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld) AND (NOT next_day)) AND (sort_time <  %d))",  days_runs[tom],  when + 36*60*60, when + 12*60*60, DAY_START); 
   strcat(query, zs);
   sprintf(zs, " OR   (((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld) AND (    next_day)) AND (sort_time <  %d)))", days_runs[day],  when + 12*60*60, when - 12*60*60, DAY_START);
   strcat(query, zs);
   
   sprintf(zs, " AND (public_departure != '' OR departure != '') AND (train_status = 'P' OR train_status = 'B' OR train_status = '1' OR train_status = '5')");
   strcat(query, zs);
   
   strcat(query, " ORDER BY LOCATE(cif_schedules.CIF_stp_indicator, 'NPO'), cif_schedule_id"); 
   
   word index, i;
   dword cif_schedule_id;
   
   // 1. Collect a list of unique schedule_id
   train_count = 0;
   //printf("<p>[%s]</p>", query);
   
   if(!db_query(query))
   {
      result0 = db_store_result();
      while((row0 = mysql_fetch_row(result0)))
      {
         //printf("<br>%s ", row0[0]);
         if(train_count >= MAX_TRAINS)
         {
            printf("<p>Error: MAX_TRAINS exceeded.</p>");
            return;
         }
         cif_schedule_id =  atol(row0[0]);
         for(i=0; i < train_count && trains[i].cif_schedule_id != cif_schedule_id; i++);
         
         if(i == train_count)
         {
            //printf(" Insert at %d", train_count);
            // Insert in array
            trains[train_count].cif_schedule_id = cif_schedule_id;
            strcpy(trains[train_count].cif_train_uid, row0[1]);
            trains[train_count].cif_stp_indicator = row0[2][0];
            trains[train_count].valid = true;
            trains[train_count].sort_time = atoi(row0[4]);
            trains[train_count].next_day = atoi(row0[3]);
            train_count++;
         }
      }
      mysql_free_result(result0);
   }
   
   // 2. Cancel any which are overriden
   for(index = 1; index < train_count; index++)
   {
      if(trains[index].valid && trains[index].cif_stp_indicator == 'O')
      {
         for(i = 0; i < index; i++)
         {
            if(!strcmp(trains[i].cif_train_uid, trains[index].cif_train_uid))
            {
               // Hit
               trains[i].valid = false;
               //printf("<br>Step 2 invalidates %d due to %d", i, index);
            }
         }
      }
   }
   
   // 3. Next, remove those which are cancelled, and remove those overriden by overlays that don't call
   // NOTE:  Overlay may not call at this station!
   sprintf(zs, "3. Commencing C and O check.  day = %d", day);
   _log(DEBUG, zs);
   
   for(index = 0; index < train_count; index++)
   {
      if(trains[index].valid)
      {
         sprintf(zs, "Testing index %d train \"%s\", sort_time = %d, next_day = %d", index, trains[index].cif_train_uid, trains[index].sort_time, trains[index].next_day );
         _log(DEBUG, zs);
         //                    0   1                 2                               3
         strcpy(query, "SELECT id, CIF_stp_indicator ");
         strcat(query, " FROM cif_schedules");
         strcat(query, " WHERE (cif_stp_indicator = 'C' OR cif_stp_indicator = 'O')");
         sprintf(zs, " AND (CIF_train_uid = '%s')", trains[index].cif_train_uid);
         strcat(query, zs);
         sprintf(zs, " AND (deleted >= %ld)", when);
         strcat(query, zs);

         if(trains[index].next_day && trains[index].sort_time >= DAY_START)
         {
            sprintf(zs, " AND ((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld))",  days_runs[yest], when - 12*60*60, when - 36*60*60);
            strcat(query, zs);
         }
         else if(trains[index].next_day && trains[index].sort_time < DAY_START)
         {
            sprintf(zs, " AND ((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld))", days_runs[day],  when + 12*60*60, when - 12*60*60);
            strcat(query, zs);
         }
         else if(!trains[index].next_day && trains[index].sort_time >= DAY_START)
         {
            sprintf(zs, " AND ((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld))",  days_runs[day],  when + 12*60*60, when - 12*60*60);
            strcat(query, zs);
         }
         else if(!trains[index].next_day && trains[index].sort_time < DAY_START)
         {
            sprintf(zs, " AND ((%s) AND (schedule_start_date <= %ld) AND (schedule_end_date >= %ld))",  days_runs[tom],  when + 36*60*60, when + 12*60*60); 
            strcat(query, zs);
         }
         if(!db_query(query))
         {
            result0 = db_store_result();
            while((row0 = mysql_fetch_row(result0)))
            {
               _log(DEBUG, "Index C or O match:");
               if(row0[1][0] == 'C')
               {
                  // Cancelled
                  trains[index].valid = false;
                  //printf("<br>Step 3:  %d invalidated due to C", index);
                  sprintf(zs, "Schedule %ld (%s) cancelled by schedule %s.", trains[index].cif_schedule_id, trains[index].cif_train_uid, row0[0]);
                  _log(DEBUG, zs);
               }
               else 
               {
                  // Overlay
                  // We will come here with an overlay we already know about OR one which *doesn't come here*
                  dword overlay_id = atol(row0[0]);
                  _log(DEBUG, "Overlay id = %ld, train id = %ld", overlay_id, trains[index].cif_schedule_id);
                  if(overlay_id != trains[index].cif_schedule_id || trains[index].cif_stp_indicator == 'N' || trains[index].cif_stp_indicator == 'P')
                  {
                     // Overlay doesn't come here.
                     trains[index].valid = false;
                     _log(DEBUG, "Step 3:  %d invalidated due to O id = %s", index, row0[0]);
                  }
               }
            }
            mysql_free_result(result0);
         }
      }
   }

   // 4. We now have a list of unique garner schedule ids, all of which call here once OR MORE
   // in the huyton_special case they may call at huyton or junction or both but will still have only one entry here.
   // All entries have .cif_schedule_location_id == 0 now, we will set this as we process them,
   // any still ==0 at the end of step 4 will be huyton_special HUYTJUN-only trains for step 4a to process. 
   _log(DEBUG, "4. Add any second calls.  Poplulate schedule_location_d field.");
   word limit = train_count;
   word instances;

   for(index = 0; index < limit; index++)
   {
      if(trains[index].valid)
      {
         instances = 0;

         sprintf(query, "SELECT sort_time, next_day from cif_schedule_locations WHERE cif_schedule_id = %ld AND tiploc_code = '%s'", trains[index].cif_schedule_id, tiploc);
         if(!db_query(query))
         {
            result1 = db_store_result();
            while((row1 = mysql_fetch_row(result1)))
            {
               if(instances++)
               {
                  // Second or subsequent visit to this location.  Append to end of array
                  trains[train_count].cif_schedule_id = trains[index].cif_schedule_id;
                  strcpy(trains[train_count].cif_train_uid, trains[index].cif_train_uid);
                  trains[train_count].cif_stp_indicator = trains[index].cif_stp_indicator;
                  trains[train_count].valid = true;
                  trains[train_count].sort_time = atoi(row0[0]);
                  trains[train_count].next_day = atoi(row0[1]);
                  _log(DEBUG, "Step 4:  Second visit for %ld, populated entry %d.", trains[index].cif_schedule_id, train_count);
                  train_count++;
               }
               else
               {
                  // First visit.  
               }
            }
            mysql_free_result(result1);
         }
      }
   }


   // 5. Bubble Sort
   {
      word i,j;

      word run = true;

      //printf("<p>Before sort: ");
      //for(j=0; j < train_count; j++)
      //{
      //   printf("<br>%d %ld %s", j, trains[j].cif_schedule_id, trains[j].valid?"":"Invalidated");
      //}
      //printf("</p>\n");

      // First, mung the sort_time so that early hours trains come after the others:
      for(j=0; j< train_count; j++)
      {
         // Early hours trains come after all the others.
         if(trains[j].sort_time < DAY_START) trains[j].sort_time += 10000;
         train_sequence[j] = j;
         //if(!trains[j].cif_schedule_location_id) printf("<br>Step 5: %d not populated.", j);
      }

      for(j = train_count; run && j > 1; j--)
      {
         run = false;
         for(i=1; i < j; i++)
         {
            if(trains[train_sequence[i]].sort_time < trains[train_sequence[i-1]].sort_time)
            {
               run = true;
               // Swap
               word tempo = train_sequence[i];
               train_sequence[i] = train_sequence[i-1];
               train_sequence[i-1] = tempo;
            }
         }
      }
   }
   
   nlate = nlater = ncape = ntrain = nbus = 0;
   for(index = 0; index < train_count; index++)
   {
      if(trains[train_sequence[index]].valid)
      {
         report_train_day(trains[train_sequence[index]].cif_schedule_id, when, tiploc);
      }
   }

   // See if there are any notes
   char notes[4096];
   strcpy(notes, "&nbsp;");
   {
      FILE * fp = fopen("/home/wielanpj/report-notes.txt", "r");
      char line[256];
      word match = false;
      if(fp)
      {
         broken = gmtime(&when);
         while(fgets(line, 256, fp))
         {
            if(line[0] == '>')
            {
               // Date
               if(broken->tm_mday == atoi(line + 1) && broken->tm_mon + 1 == atoi(line + 4) && broken->tm_year % 100 == atoi(line + 7))
               {
                  match = true;
                  notes[0] = '\0';
               }
               else
               {
                  match = false;
               }
            }
            else if(match && line[0] != '\n') strcat(notes, line);
         }
         fclose(fp);
      }
      if(notes[strlen(notes) - 1] == '\n') notes[strlen(notes) - 1] = '\0';
   }

   if(ntrain)
   {
      printf("<tr><td>%s %02d</td><td>%d</td><td>%d</td><td>(%s%%)</td>",
             days[day % 7], mday, ntrain, ntrain-ncape, percentage(ntrain-ncape, ntrain));
      printf("<td>%d</td><td>(%s%%)</td>",
             ntrain - nlate, percentage(ntrain - nlate, ntrain));
      printf("<td>%d</td><td>(%s%%)</td><td align=\"left\">%s</td></tr>\n",
             ntrain - nlater, percentage(ntrain - nlater, ntrain), notes);
   }
   else
   {
      printf("<tr><td>%s %02d</td><td>%d</td><td>%d</td><td>&nbsp;</td>",
             days[day % 7], mday, ntrain, ntrain-ncape);
      printf("<td>%d</td><td>&nbsp;</td>",
             ntrain - nlate);
      printf("<td>%d</td><td>&nbsp;</td><td align=\"left\">%s</td></tr>\n",
             ntrain - nlater, notes);
   }

   gtrain += ntrain;
   gcape += ncape;
   glate += nlate;
   glater += nlater;
   gbus += nbus;
}

static void report_train_day(const dword cif_schedule_id, const time_t when, const char * const tiploc)
{
   MYSQL_RES * result0, * result1;
   MYSQL_ROW row0, row1;

   char query[1024];
   word vstp, status;
   char actual[16], expected[16];
   word deviation, deduced, late;
   word next_day, sort_time;
   char depart[8];
   struct tm * broken;

   deviation = late = status = bus = deduced = 0;
   
   _log(DEBUG, "report_train_day(%ld, %ld, \"%s\")", cif_schedule_id, when, tiploc);
   
   // N.B.  The following wont work properly for a second call!
   //                         0         1            2               3
   sprintf(query, "select next_day, sort_time, public_departure, departure from cif_schedule_locations where cif_schedule_id = %ld AND tiploc_code = '%s'", cif_schedule_id, tiploc);
   db_query(query);
   result0 = db_store_result();
   if((row0 = mysql_fetch_row(result0)))
   {
      next_day        = atoi(row0[0]);
      sort_time       = atoi(row0[1]);
      strcpy(depart, row0[2]);
      if(!depart[0]) strcpy(depart, row0[3]);
      strcpy(expected, row0[2]);
      _log(DEBUG, "Got schedule id etc.");
   }
   else
   {
      _log(MAJOR, "report_train() failed to select call details.");
      return;
   }
   mysql_free_result(result0);

   // Calculate start_date from when, deducting 24h if next_day and/or adding 24h if after 00:00.
   time_t start_date = when - (next_day?(24*60*60):0);
   if(sort_time < DAY_START) start_date += (24*60*60);

   //                     0             1                    2                  3              4              5                  6           
   sprintf(query, "SELECT train_status, schedule_start_date, schedule_end_date, signalling_id, CIF_train_uid, CIF_stp_indicator, update_id FROM cif_schedules WHERE id = %ld", cif_schedule_id);

   if(!db_query(query))
   {
      result0 = db_store_result();

      if((row0 = mysql_fetch_row(result0)))
      {
         vstp = (row0[6][0] == '0' && row0[6][1] == 0);
         bus = (row0[0][0] == 'B' || row0[0][0] == '5');

         if(!bus) ntrain++;
         status = 0;
         // TRUST
         if(!bus)
         {
            // TEMPO
            _log(CRITICAL, "CIF schedule id %ld is a train!", cif_schedule_id);
            // TEMPO

            char query[512], trust_id[16];
            MYSQL_RES * result2;
            MYSQL_ROW row2;
            broken = gmtime(&start_date);
            byte dom = broken->tm_mday;

            // Only accept activations where dom matches, and are +- 15 days (To eliminate last month's activation.)  YUK
            sprintf(query, "SELECT created, trust_id, deduced FROM trust_activation WHERE cif_schedule_id = %ld AND substring(trust_id FROM 9) = '%02d' AND created > %ld AND created < %ld order by created", cif_schedule_id, dom, when - 15*24*60*60, when + 15*24*60*60);
            if(!db_query(query))
            {
               result1 = db_store_result();
               if((row1 = mysql_fetch_row(result1)))
               {
                  status = 1;
                  strcpy(trust_id, row1[1]);
               }
               mysql_free_result(result1);
            }

            if(status)
            {
               sprintf(query, "SELECT event_type, loc_stanox, actual_timestamp, timetable_variation, variation_status from trust_movement where trust_id='%s' AND created > %ld AND created < %ld order by actual_timestamp, planned_timestamp, created", trust_id, when - 15*24*60*60, when + 15*24*60*60);
               if(!db_query(query))
               {
                  result1 = db_store_result();
                  while((row1 = mysql_fetch_row(result1)))
                  {
                     if(status < 4)
                     {
                        status = 2;
                        strcpy(actual, row1[2]);
                        deviation = atoi(row1[3]);
                        late = !strcasecmp("late", row1[4]);
                     }
                     if(status < 5)
                     {
                        sprintf(query, "SELECT tiploc FROM corpus WHERE stanox = %s", row1[1]);
                        if(!db_query(query))
                        {
                           result2 = db_store_result();
                           if((row2 = mysql_fetch_row(result2)))
                           {
                              if(!strcasecmp(tiploc, row2[0]))
                              {
                                 if(!strcasecmp("departure", row1[0]))
                                 {
                                    // Got a departure report at our station
                                    status = 5;
                                    strcpy(actual, row1[2]);
                                    deviation = atoi(row1[3]);
                                    late = !strcasecmp("late", row1[4]);
                                 }
                                 else if(status < 4)
                                 {
                                    // Got an arrival from our station AND haven't seen a departure yet
                                    status = 4;
                                 }
                              }
                           }
                           mysql_free_result(result2);
                        }
                     }
                  }
                  mysql_free_result(result1);
               }
            }
            
            if(status < 4)
            {
               word save_status = status;
               sprintf(query, "SELECT created, reason, type, reinstate from trust_cancellation where trust_id='%s' AND created > %ld AND created < %ld order by created ", trust_id, when - 15*24*60*60, when + 15*24*60*60);                  
               if(!db_query(query))
               {                   
                  result2 = db_store_result();
                  while((row2 = mysql_fetch_row(result2)))
                  {
                     if(atoi(row2[3]))
                     {
                        status = save_status;
                     }
                     else
                     {
                        status = 3;
                     }
                  }
                  mysql_free_result(result2);
                  
               }
            }
         }
      }
      mysql_free_result(result0);
   }

   // Build analysis
   switch(status)
   {
   case 0: 
      if(bus) 
      {
         nbus++;
      }
      break;

   case 1: // Activated
      break;

   case 2: // Moved
      if(deviation > 2) nlate++;
      if(deviation > 5) nlater++;
      break;

   case 3: // Cape
      ncape++;
      break;

   case 4: // Arrived
   case 5: // Departed
      if(deviation > 2) nlate++;
      if(deviation > 5) nlater++;
      break;

   }

   return;
}

static char * percentage(const dword num, const dword den)
{
   static char result[16];

   if(den)
   {
      dword permille = 1000 * num / den;
      sprintf(result, "%ld.%ld", permille/10, permille%10);
   }
   else
   {
      strcpy(result, "-");
   }

   return result;
}
